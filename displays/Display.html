<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Unagi</title>
    <style type="text/css">
        :root {
            --desktop-font-size: 1.3rem/1.5;
            --mobile-font-size: 1.1rem/1.4;
            --text-color: #2d2d2d;
            --link-color: blue;
            --primary-color: lightsteelblue;
            --secondary-color: aliceblue;
            --tertiary-color: whitesmoke;
        }

        /* Typography */

        /* html legyen display: flex, és body legyen flex: 1, height: 100%. NE HASZNÁLJ MARGINT, CSAK PADDINGET, HA NEM AKARSZ GÖRGŐT!!! A margin a méreten kívülre kerül, ezért kitolja a területet. */
        /* Minden flexes konténernél legyen ott a display:flex is!!!*/
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            display: flex;
        }
        body {
            margin: 0;
            padding: 0;
            flex: 1;
            height: 100%;
            font-family: Helvetica, sans-serif;
        }

        h1 {
            margin: 0;
        }

        p {
            margin: 0;
            flex: 1;
        }

        .padding {
            display: flex;
            flex: 0.05;
        }

        #row_wrapper {
            display: flex;
            flex: 1;
            flex-direction: row; /* az elemek oszlopban vannak egymáson, de csak ha a display:flex is be van állítva */
            height: 100%;
        }

        #col_wrapper {
            display: flex;
            flex: 0.9;
            flex-direction: column; /* az elemek oszlopban vannak egymáson, de csak ha a display:flex is be van állítva */
            width: 100%;
        }

        #main_title {
            padding: 0;
        }

        #wrapper {
            display: flex;
            flex-direction: row;
            flex: 1;
            height: 100%;
        }

        #btn_canvas_wrapper {
            display: block;
            flex: 0.7;
            flex-direction: column;
            width: 100%;

        }

        #canvas_wrapper {
            display: block;
        }

        canvas {
            display: block;
            border: solid black 2px;
            width: 100%;
            height: 100%;
        }

        #btn_wrapper {
            display: block;
        }

        #infos_wrapper {
            flex: 0.3;
            display: flex;
            flex-direction: row;
        }

        #infos {
            flex: 0.95;
            display: flex;
            flex-direction: column;
        }

        #json_selector {
            display: block;
            flex: 0.25;
        }

        #disp_info {
            display: flex;
            flex-direction: row;
            flex: 0.75;
        }

        #label_titles {
            flex: 0.8;
            display: flex;
            flex-direction: column;
        }

        #label_values {
            flex: 0.2;
            display: flex;
            flex-direction: column;
        }


        .btn {
            float: right;
            margin-left: 10px;
            margin-top: 10px;
            width: 50px;
            height: 30px;
        }

        /* On Mobile */
        @media screen and (max-width: 50rem) {
            body {
                font-family: Helvetica, sans-serif;
            }

            table {
                table-layout: auto;
            }
        }
    </style>
</head>

<body>
    <div id="row_wrapper">
        <div class="padding"></div>
        <div id="col_wrapper">
            <div class="padding"></div>
            <h1 id="main_title">Vírusirtók - Ericsson bajnokság 2020</h1>
            <br>
            <div id="wrapper">
                <div id="btn_canvas_wrapper">
                    <div id="canvas_wrapper">
                        <canvas id="canvas"></canvas>
                    </div>
                    <div id="btn_wrapper">
                        <button class="btn" id="next_btn">></button>
                        <button class="btn" id="prev_btn"><</button>
                    </div>
                </div>
                <div id="infos_wrapper">
                    <div class="padding"></div>
                    <div id="infos">
                        <div id="json_selector">
                            <form id="jsonFile" name="jsonFile" enctype="multipart/form-data" method="post">
                                <fieldset>
                                    <h2>Json File</h2>
                                    <input type='file' id='fileinput'>
                                </fieldset>
                            </form>
                        </div>
                        <div id="disp_info">
<!--                            info text displayed-->
                            <div id="label_titles">
                                <label>Number of countries: </label>
                                <label>Country ID: </label>
                                <label>Max tick: </label>
                                <label>Current tick: </label>
                            </div>
                            <div id="label_values">
                                <label id="num_of_countries"></label>
                                <label id="country_id"></label>
                                <label id="max_tick_label"></label>
                                <label id="tick_label"></label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="padding"></div>
        </div>
        <div class="padding"></div>
    </div>

    <script type="text/javascript">
        let fileinput = document.getElementById('fileinput');
        let canvas = document.getElementById("canvas"),
            context = canvas.getContext("2d");
        let tick_label = document.getElementById("tick_label");
        let next_btn = document.getElementById("next_btn");
        let prev_btn = document.getElementById("prev_btn");

        let curr_tick = 0;
        let max_tick = 0;
        let N = 5;
        let M = 5;
        let district_colors = {};
        let disp_info;

        function DrawMap() {
            let f_width = canvas.width /N;
            let f_heigh = canvas.height /M;
            let divider = 6;
            let text_divider = 10;

            // Háttér területek megrajzolása
            if (max_tick !== 0) {
                for(let i = 0; i < N; i++) {
                    for (let j = 0; j < M; j++) {
                        context.fillStyle = 'rgb(150,150,150)';
                        context.fillRect(i*f_width, j*f_heigh, f_width, f_heigh);

                        let color;
                        if (disp_info.district[j][i] in district_colors){
                            color = district_colors[disp_info.district[j][i]];
                        }
                        else {
                            R = Math.floor(Math.random()*255);
                            G = Math.floor(Math.random()*255);
                            B = Math.floor(Math.random()*255);

                            color = {R, G, B};
                            district_colors[disp_info.district[j][i]] = {R, G, B};
                        }

                        context.fillStyle ='rgba('+color.R+','+color.G+','+color.B+',0.5)';
                        context.fillRect(i*f_width+1, j*f_heigh+1, f_width-2, f_heigh-2);
                    }
                }

                for (let i = 0; i < N; i++) {
                    for (let j = 0; j < M; j++) {
                        let txt;
                        let txt_offset = 10;
                        // Infection_rate
                        context.font = String(f_width / text_divider) + "px Helvetica";

                        let x = 255 - disp_info.infection_rate[curr_tick][j][i] * 255 / 100;
                        context.fillStyle = 'rgb(255,' + String(x) + ',' + String(x) + ')';
                        context.align = "center";
                        txt = disp_info.infection_rate[curr_tick][j][i];
                        context.fillText(txt, i * f_width + f_width / 2 - 2, j * f_heigh + f_heigh / 2 + 3);

                        // Population
                        context.fillStyle = 'rgb(158,185,226)';
                        context.fillRect(i * f_width + 1, j * f_heigh + 1, f_width / divider, f_heigh / divider);

                        context.font = String(f_width / 2 / text_divider) + "px Helvetica";
                        context.fillStyle = "white";
                        context.align = "center";
                        txt = disp_info.population[j][i];
                        context.fillText(txt, i * f_width + f_width / divider / 2 - txt_offset, j * f_heigh + f_heigh / divider / 2 + txt_offset);

                        // District
                        let color = district_colors[disp_info.district[j][i]];
                        context.fillStyle = 'rgba(' + color.R + ',' + color.G + ',' + color.B + ',0.5)';
                        context.fillRect(i * f_width + 1, j * f_heigh + 1 + f_heigh / divider, f_width / divider, f_heigh / divider);

                        context.font = String(f_width / 2 / text_divider) + "px Helvetica";
                        context.fillStyle = "white";
                        context.align = "center";
                        txt = disp_info.district[j][i];
                        context.fillText(txt, i * f_width + f_width / divider / 2 - txt_offset, j * f_heigh + f_heigh / divider / 2 + txt_offset + f_heigh / divider);

                        // A healing és az inf el vannak tolódva, mindig azt az inf_rate-et látom, amivel változott azt előző állapot
                        if (curr_tick + 1 !== max_tick) {
                            // Infection
                            context.fillStyle = 'rgba(255, 255,255, 0.7)';
                            context.fillRect(i * f_width + 1 + f_width - f_width / divider, j * f_heigh + 1, f_width / divider, f_heigh / divider);

                            context.font = String(f_width / 2 / text_divider) + "px Helvetica";
                            context.fillStyle = "red";
                            context.align = "center";
                            txt = disp_info.infection[curr_tick + 1][j][i];
                            context.fillText("+ " + txt, i * f_width + f_width / divider / 2 - txt_offset + f_width - f_width / divider, j * f_heigh + f_heigh / divider / 2 + txt_offset);

                            // Healing
                            context.fillStyle = 'rgba(255, 255,255, 0.7)';
                            context.fillRect(i * f_width + 1 + f_width - f_width / divider, j * f_heigh + 1 + f_heigh / divider, f_width / divider, f_heigh / divider);

                            context.font = String(f_width / 2 / text_divider) + "px Helvetica";
                            context.fillStyle = "green";
                            context.align = "center";
                            txt = disp_info.healing[curr_tick + 1][j][i];
                            context.fillText("- " + txt, i * f_width + f_width / divider / 2 - txt_offset + f_width - f_width / divider, j * f_heigh + f_heigh / divider / 2 + txt_offset + f_heigh / divider);
                        }

                        // Health rate
                        context.fillStyle = 'rgba(0,0,0, 0.4)';
                        context.fillRect(i * f_width + 1 + 0 * f_width / divider, j * f_heigh + 1 + f_heigh - f_heigh / divider, f_width / divider, f_heigh / divider);

                        context.font = String(f_width / 2 / text_divider) + "px Helvetica";
                        context.fillStyle = "white";
                        context.align = "center";
                        txt = disp_info.health_rate[curr_tick][j][i];
                        let extra_txt_offset = 20;
                        context.fillText("HR: " + txt, i * f_width + f_width / divider / 2 - txt_offset - extra_txt_offset, j * f_heigh + f_heigh / divider / 2 + txt_offset + f_heigh - f_heigh / divider);

                    }
                }
            }
            else {
                for(let i = 0; i < N; i++) {
                    for (let j = 0; j < M; j++) {
                        context.fillStyle = 'rgba(150,150,150,1)';
                        context.fillRect(i*f_width, j*f_heigh, f_width, f_heigh);

                        context.fillStyle = 'rgba(255,255,255,0.5)';
                        context.fillRect(i*f_width+1, j*f_heigh+1, f_width-2, f_heigh-2);
                    }
                }
            }
        }

        function next_tick() {
            if (curr_tick < max_tick-1) {
                curr_tick++;
                tick_label.innerHTML = curr_tick;

                DrawMap();
            }
            if (curr_tick+1 === max_tick) {
                curr_tick = 0;
                tick_label.innerHTML = curr_tick;

                DrawMap();
            }
        }

        function prev_tick() {
            if (curr_tick > 0) {
                curr_tick--;
                tick_label.innerHTML = curr_tick;

                DrawMap();
            }
            if (curr_tick === 0 && max_tick !== 0) {
                curr_tick = max_tick-1;
                tick_label.innerHTML = curr_tick;

                DrawMap();
            }
        }

        function refreshGameVariables() {
            curr_tick = 0;
            N = disp_info.N;
            M = disp_info.M;
            max_tick = disp_info.max_tick;

            let num_of_countries = document.getElementById("num_of_countries");
            num_of_countries.innerHTML = disp_info.num_of_countries;
            let country_id = document.getElementById("country_id");
            country_id.innerHTML = disp_info.country_id;
            let max_tick_label = document.getElementById("max_tick_label");
            max_tick_label.innerText = disp_info.max_tick;
            tick_label.innerHTML = curr_tick;

            DrawMap();
        }

        function loadFile() {
            let file, fr;
            let input = document.getElementById('fileinput');
            if (!input) {
                alert("Couldn't find the fileinput element.");
            } else if (!input.files) {
                alert("This browser doesn't seem to support the `files` property of file inputs.");
            } else {
                file = input.files[0];
                fr = new FileReader();
                fr.onload = receivedText;
                fr.readAsText(file);
            }

            function receivedText(e) {
                let lines = e.target.result;
                disp_info = JSON.parse(lines);
                refreshGameVariables();
            }
        }

        function getMousePos(event) {
            let rect = canvas.getBoundingClientRect();
            let scaleX = canvas.width / rect.width;
            let scaleY = canvas.height / rect.height;

            return {
                x: (event.clientX - rect.left) * scaleX,   // scale mouse coordinates after they have
                y: (event.clientY - rect.top) * scaleY     // been adjusted to be relative to element
            }
        }

        function resizeCanvas() {
            canvas.width = canvas.clientWidth*2; // a szorzóval állítható a canvas felbontása
            canvas.height = canvas.width/1.8;
            DrawMap();
        }

        // a <script> tag scopejában lévő függvényívások loopolva vannak
        resizeCanvas();
        // Event handler to resize the canvas when the document view is changed
        fileinput.onchange = loadFile;
        next_btn.addEventListener("click", next_tick);
        prev_btn.addEventListener("click", prev_tick);
        window.addEventListener('resize', resizeCanvas, false);
        canvas.addEventListener('mousemove', event => {
            let P = getMousePos(event);
            //context.fillRect(P.x, P.y, 1, 1);
        })
    </script>
</body>
</html>